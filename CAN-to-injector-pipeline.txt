# ðŸš¦ **1. CAN bus delivers torque + RPM**
Upstream ECU (or your dyno controller) sends a CAN frame:

```
ID: 0x200
Bytes:
  [0â€“1] = RPM (uint16)
  [2â€“3] = Torque Request (uint16)
```

The Teensyâ€™s CAN controller receives it, and the ISR updates two globals:

- `engineRPM`
- `torqueRequest`

These values are now the **authoritative inputs** for the next 8 kHz control cycle.

Nothing else in the system touches torque or RPM.

---

# ðŸ§  **2. Teensyâ€™s 8 kHz loop wakes up**
Every 125 microseconds, the Si5351â€™s 8 kHz sync pulse triggers the Teensy ISR.

Inside that ISR:

### The Teensy reads:
- MAP (ADC)
- EMP (ADC)
- EGT (ADC)
- Turbo speed (FreqMeasureMulti)
- The latest CAN torque + RPM

### The Teensy filters:
- MAP, EMP, EGT â†’ exponential smoothing  
- Turbo speed â†’ frequency â†’ RPM conversion  
- Torque request â†’ no smoothing (must be responsive)

### The Teensy checks safety:
- Overâ€‘EGT  
- Overâ€‘boost  
- Overâ€‘EMP  
- Drive ratio limit  
- Turbo overspeed  

If anything is unsafe:
- `systemHealthy = false`
- `LOOP_ENABLE = LOW`
- **All injectors stop instantly** (hardware domain powers down)

If safe:
- Continue.

---

# ðŸ“Š **3. Teensy consults the 16Ã—16 maps**
Using the CAN torque request and CAN RPM:

```
vntDuty  = VNTmap.interpolate(torque, rpm)
lpgPulse = LPGmap.interpolate(torque, rpm)
wgDuty   = WGmap.interpolate(torque, rpm)
```

These maps are 16Ã—16 CSV tables stored on SD.

The Teensy applies:
- VNT inversion (if configured)
- Singleâ€‘turbo fadeout (if configured)
- LPG scale factor

Then it updates PWM outputs for:
- VNT
- WG
- LPG

This is the **softwareâ€‘timed** part of the system.

---

# ðŸ”¢ **4. Teensy computes injector parameters**
For each of the 12 injectors:

```
pulse = torqueRequest * injFuelScale[i]
pulse = clamp(0â€“255)

meta = 0
if injEnable[i]: meta |= 1
meta |= (injPhase[i] & 0x07) << 1
```

So each injector gets:

- **Pulse width** (low byte)
- **Metadata** (high byte)
  - Enable bit
  - Phase bits
  - Trim bits (future)

This 16â€‘bit word is written into the SRAM at address = injector index.

This is the **software â†’ hardware boundary**.

---

# ðŸ§± **5. SRAM becomes the injector timing table**
The IS62WV25616 SRAM now holds:

| Address | Injector | Low Byte | High Byte |
|---------|----------|----------|-----------|
| 0 | #1 | pulse | metadata |
| 1 | #2 | pulse | metadata |
| â€¦ | â€¦ | â€¦ | â€¦ |
| 11 | #12 | pulse | metadata |

The Teensy is done.

From here on, **hardware takes over**.

---

# â±ï¸ **6. Si5351A drives the timing engine**
The Si5351 outputs:

- **1 MHz clock** â†’ 74HC161 counters  
- **8 kHz clock** â†’ Teensy sync (already used)

The 1 MHz clock is the **time axis** for injection.

Every microsecond, the counter increments.

---

# ðŸ”„ **7. 74HC161 counters generate â€œcurrent timeâ€**
The counters freeâ€‘run:

```
0 â†’ 255 â†’ reset â†’ 0 â†’ ...
```

Modulo is set by DIP switches (cylinder count).

Their 8â€‘bit output is the **current time in the injection cycle**.

---

# âš–ï¸ **8. Comparator checks: â€œIs it time to end the pulse?â€**
The CD74HC688 receives:

- A inputs â† counter value  
- B inputs â† SRAM pulse width  

When:

```
counter == pulse_width
```

The comparator output toggles.

This is the **exact microsecond** the injector pulse should end.

No jitter.  
No CPU.  
No interrupts.  
Pure hardware.

---

# ðŸ“ **9. Flipâ€‘flop shapes the injector pulse**
The 74HC74:

- Sets at cycle start  
- Resets when comparator fires  
- Outputs a clean, stable pulse window  

This produces a **perfectly timed injector pulse**.

---

# ðŸš¦ **10. AND gates apply enable + phase logic**
The 74HC08 AND gates combine:

- Pulse window  
- Metadata bits (enable, phase)  
- DIP enable mask  

This allows:

- Perâ€‘cylinder enable/disable  
- Phase grouping  
- Hardware safety gating  

The output is a **logicâ€‘level injector command**.

---

# âš¡ **11. GaN driver fires the injector**
Each LMG3411 receives:

- Logicâ€‘level IN from 74HC08  
- Power from injector supply  
- Local decoupling  
- Fault monitoring  

When IN goes high:
- GaN FET sinks injector current  
- Injector opens  
- Fuel flows  

When IN goes low:
- Injector closes  
- GaN reports any fault  

FAULT pins â†’ wiredâ€‘OR â†’ optocoupler â†’ Teensy.

If any GaN faults:
- Teensy drops LOOP_ENABLE  
- Entire timing domain powers down  
- Injectors stop instantly  

---

# ðŸ” **12. The cycle repeats â€” 8,000 times per second**
Every 125 Âµs:

- CAN updates torque + RPM  
- Teensy updates maps + injector parameters  
- SRAM updates  
- Hardware timing engine runs independently  
- GaN drivers fire injectors with perfect precision  

This is the **CAN â†’ injector pipeline**, endâ€‘toâ€‘end.
